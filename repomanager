#!/bin/bash
set -u
export LC_ALL="fr_FR.UTF-8" # Afin que crontab exécute ce programme avec des locales en français
export TERM="xterm-256color"
export COLUMNS=190
export GPG_TTY=$(tty)


## ↓ VARIABLES ↓ ##
# Import de toutes les variables nécéssaires au programme
if [ -f "/etc/repomanager/vars/customs.vars" ];then
	source "/etc/repomanager/vars/customs.vars"
else
	echo "Erreur : impossible de trouver le fichier de variables customs.vars"
	exit
fi

if [ -f "/etc/repomanager/vars/main.vars" ];then
	source "/etc/repomanager/vars/main.vars"
else
	echo "Erreur : impossible de trouver le fichier de variables main.vars"
	exit
fi

# Si on ne connait pas l'OS ni sa version, on quitte
if [ -z "$OS_FAMILY" ];then
	echo -e "[$JAUNE ERREUR ${RESET}] L'OS de cette machine n'a pas été reconnu (Debian, Redhat...)"
	exit
fi
if [ -z "$OS_VERSION" ];then
	echo -e "[${ROUGE} ERREUR ${RESET}] La version d'OS n'est pas connue (vide)"
	exit
fi


## ↓ FONCTIONS ↓ ##

print_help() { 
SEP
echo -e "\n
${JAUNE}Toutes les opérations s'effectuent depuis l'interface web.${RESET}
\n
Paramètres disponibles en ligne de commande :
  --repo, --list-repos, -r                  ➤  Afficher la liste des repos actifs
  --archrepo, --list-archived-repos, -ar    ➤  Afficher la liste des repos archivés
  --check, -c                               ➤  Vérification des fichiers de configuration de repomanager
\n"
SEP
clean_exit
}

# Première installation ou réinstallation du fichier de conf repomanager.conf
install() { source "${FUNCTIONS}/00_install"; }

# Vérification des dépendances
checkDependencies() { source "${FUNCTIONS}/00_checkDependencies"; }

# Vérifiction de la conf repomanager.conf
checkConf() { source "${FUNCTIONS}/00_checkConf"; }

# Récupération de la conf repomanager.conf
getConf() {	source "${FUNCTIONS}/00_getConf"; }

newRepo() {
	if [ "$OS_FAMILY" == "Redhat" ];then source "${FUNCTIONS}/01_newRepo-rpm";fi
	if [ "$OS_FAMILY" == "Debian" ];then source "${FUNCTIONS}/01_newRepo-deb";fi
}

updateRepo() {
	if [ "$OS_FAMILY" == "Redhat" ];then source "${FUNCTIONS}/02_updateRepo-rpm";fi
	if [ "$OS_FAMILY" == "Debian" ];then source "${FUNCTIONS}/02_updateRepo-deb";fi
}

duplicateRepo() {
	if [ "$OS_FAMILY" == "Redhat" ];then source "${FUNCTIONS}/03_duplicateRepo-rpm";fi
	if [ "$OS_FAMILY" == "Debian" ];then source "${FUNCTIONS}/03_duplicateRepo-deb";fi
}

changeEnv() {
	if [ "$OS_FAMILY" == "Redhat" ];then source "${FUNCTIONS}/03_changeEnv-rpm";fi
	if [ "$OS_FAMILY" == "Debian" ];then source "${FUNCTIONS}/03_changeEnv-deb";fi
}

# only for Debian
deleteSection() { 
	source "${FUNCTIONS}/04_deleteSection"
}

# only for Debian
deleteDist() { 
	source "${FUNCTIONS}/05_deleteDist" 
}

deleteRepo() {
	if [ "$OS_FAMILY" == "Redhat" ];then source "${FUNCTIONS}/06_deleteRepo_rpm";fi
	if [ "$OS_FAMILY" == "Debian" ];then source "${FUNCTIONS}/06_deleteRepo_deb";fi
}

deleteOldRepo() {
	if [ "$OS_FAMILY" == "Redhat" ];then source "${FUNCTIONS}/07_deleteOldRepo_rpm";fi
	if [ "$OS_FAMILY" == "Debian" ];then source "${FUNCTIONS}/07_deleteOldRepo_deb";fi
}

restoreOldRepo() {
	if [ "$OS_FAMILY" == "Redhat" ];then source "${FUNCTIONS}/08_restoreOldRepo_rpm";fi
	if [ "$OS_FAMILY" == "Debian" ];then source "${FUNCTIONS}/08_restoreOldRepo_deb";fi
}

generateConf() {
	source "${FUNCTIONS}/09_generateConf"
}

deleteConf() {
	source "${FUNCTIONS}/09_deleteConf"
}

execPlan() {
	source "${FUNCTIONS}/20_planifications"
	execute $PLAN_ID
}

planReminders() {
	source "${FUNCTIONS}/20_planifications"
	sendReminders
}

cleanArchives() {
	source "${FUNCTIONS}/21_cleanArchives"
}

sendMail() {
	source "${FUNCTIONS}/22_sendMail"
}

sendPlanReminderMail() {
	source "${FUNCTIONS}/23_sendPlanReminderMail"
}

cronjob_daily() {
	source "${FUNCTIONS}/30_cronjob_daily"
}

# Tri par ordre alpha des fichiers de listes de repos
sortLists() { source "${FUNCTIONS}/98_sortLists"; }

# Affichage de la liste des repos/sections dans le terminal
listRepo() { source "${FUNCTIONS}/98_listRepo"; }

# Affichage de la liste des repos/sections archivés dans le terminal
listOldRepo() {	source "${FUNCTIONS}/98_listOldRepo"; }

# Mise à jour de repomanager à partir de git
update() { source "${FUNCTIONS}/99_update"; }

# Remise en place des permissions sur les répertoires utilisés par le programme
permissions() {	source "${FUNCTIONS}/100_permissions"; }

# Nettoyage et fin du programme
clean_exit() { source "${FUNCTIONS}/999_cleanExit"; }


## Autres fonctions ##

nettoyage_fichier_conf() {    # Retire les commentaires et les lignes vides du fichier passé en paramètre et le renvoi dans le fichier $CONF_NETTOYEE
CONF_NETTOYEE="/tmp/repomanager_conf_clean.txt"                 	# Ce fichier est destiné à récupérer le contenu du fichier de conf sans les commentaires ni espaces blancs
echo -n> "$CONF_NETTOYEE"
sed "/^[ \t]*#.*/d" $CONF | sed "/^[ \t]*$/d" > "$CONF_NETTOYEE"    # Suppression des commentaires et espaces blancs du fichier de liste passé en argument
CONF="$CONF_NETTOYEE"                                               # La variable $CONF devient le fichier de liste nettoyé précedemment
}

espace_disque() {
echo -ne "\nEspace restant sur le serveur : "
ESPACE_DISQUE=$(df | egrep "/$" | awk '{print $4}')   # Affichage de l'espace restant sur /home
if [ $ESPACE_DISQUE -lt 50000000 ];then
    echo -ne "${ROUGE}"
    df -h | egrep "/$" | awk '{print $4}'
    echo -ne "${RESET}"
elif [ $ESPACE_DISQUE -lt 100000000 ];then
    echo -ne "${JAUNE}"
    df -h | egrep "/$" | awk '{print $4}'
    echo -ne "${RESET}"
else
    df -h | egrep "/$" | awk '{print $4}'
fi

echo ""
}





## TRAITEMENT ##

# Pré-lecture des paramètres, initialisation de variables supplémentaires
if [ $# -ge "1" ];then
	case "$1" in
		--cronjob-daily)
			TTY="0"
			checkConf
			getConf
			cronjob_daily
			clean_exit
		;;
		--exec-plan)
			TTY="0"
			LOGNAME="plan_${DATE_AMJ}_${HEURE_HMS}.log" # On ré-écrit le nom du fichier de log afin de le différencier des fichier de log commencant par repomanager_
			LOG="${MAIN_LOGS_DIR}/${LOGNAME}"
			PLAN_EXEC=1
			PLAN_ID=$2
		;;
		--planReminder)
			TTY="0"
			KEEP_LOG="no"
		;;
	esac
fi
# Si aucun paramètre n'a été passé au programme, on ne fait pas la rotation de lastlog et on ne conserve pas le fichier de log
if [ $# -eq "0" ];then
	KEEP_LOG="no"
fi

# Crée les répertoire de base si n'existent pas
mkdir -p "${BASE_DIR}"
mkdir -p "${REPOS_DIR}"

# Création du répertoire de logs si n'existe pas
mkdir -p "${MAIN_LOGS_DIR}/"

# Vidage des fichiers de logs
echo -n> "$LOG"
chmod 660 "$LOG"

# On écrit tout ce qu'il se passe dans le fichier de log principal
if [ "$KEEP_LOG" == "yes" ];then exec &> >(tee -a "$LOG");fi

# On récupère les infos sur la précédente exécution du programme dans le fichier de log précédent
if [ -f "${MAIN_LOGS_DIR}/lastlog.log" ];then
	LAST_EXECUTION_DATE=$(readlink -f ${MAIN_LOGS_DIR}/lastlog.log | awk -F '/' '{print $NF}' | awk -F '_' '{print $2}')
	LAST_EXECUTION_DATE=$(date -d"$LAST_EXECUTION_DATE" +%d-%m-%Y)
	LAST_EXECUTION_TIME=$(readlink -f ${MAIN_LOGS_DIR}/lastlog.log | awk -F '/' '{print $NF}' | awk -F '_' '{print $3}' | sed 's/.log//g' | sed 's/-/:/g')
	LAST_EXECUTION_TIME=$(date -d"$LAST_EXECUTION_TIME" +%Hh%Mm%Ss)
	LAST_EXECUTION_USER="$(cat ${MAIN_LOGS_DIR}/lastlog.log | grep 'Exécuté par' | sed 's/.*: //g')"
	LAST_EXECUTION_MESSAGE="Le ${LAST_EXECUTION_DATE} à ${LAST_EXECUTION_TIME} (${LAST_EXECUTION_USER})"
else
	LAST_EXECUTION_MESSAGE="N/A"
fi

# Puis on recrée un lien symbolique 'lastlog.log' pointant vers le fichier de log en cours
if [ "$KEEP_LOG" == "yes" ];then
	# Suppression du lien symbolique pointant vers le précédent log, puis création d'un nouveau
	rm -f "${MAIN_LOGS_DIR}/lastlog.log"
	ln -sf "$LOG" "${MAIN_LOGS_DIR}/lastlog.log"

	# Si l'opération en cours est issue d'une planification alors on crée aussi un lien symbolique lastplanlog.log
	if [ "$PLAN_EXEC" -eq "1" ];then
		rm -f "${MAIN_LOGS_DIR}/lastplanlog.log"
		ln -sf "$LOG" "${MAIN_LOGS_DIR}/lastplanlog.log"
	fi
fi

# Affichage du logo ASCI repomanager
cat "${FUNCTIONS}/logo"                                                            

# Affichage de la version en cours et vérification de la disponibilité d'une nouvelle version sur github
printf "%-30s %s" "   ${JAUNE}Version" "${RESET}: $VERSION "

if [ -f "${BASE_DIR}/cron/github.version" ];then
	GITHUB_VERSION=$(grep '^GITHUB_VERSION=' ${BASE_DIR}/cron/github.version | awk -F= '{print $2}' | sed 's/"//g')
fi
if [ -z "$GITHUB_VERSION" ];then
    echo ""
# Compare la version de github avec la version actuelle :
elif [ "$VERSION" != "$GITHUB_VERSION" ];then
	UPDATE_AVAILABLE="1"
    echo -e "(${JAUNE}nouvelle version disponible sur github${RESET})"
else # Si il n'y a pas de mise à jour, on n'affiche rien, mais on saute une ligne
    echo ""
fi

printf "%-30s %s\n" "   ${JAUNE}OS" "${RESET}: $OS_NAME $OS_VERSION ($OS_FAMILY)"
if [ "$OS_FAMILY" == "Redhat" ];then
	printf "%-30s %s\n" "   ${JAUNE}Paquets gérés" "  ${RESET}: rpm"
fi
if [ "$OS_FAMILY" == "Debian" ];then
	printf "%-30s %s\n" "   ${JAUNE}Paquets gérés" "  ${RESET}: deb"
fi

WHOAMI=$(whoami)
printf "%-30s %s\n" "   ${JAUNE}Exécuté par" "  ${RESET}: $WHOAMI"
printf "%-30s %s\n" "   ${JAUNE}Exécuté" "  ${RESET}: Le $DATE_JMA à $HEURE_HhMmSs"
printf "%-30s %s\n" "   ${JAUNE}Dernière exécution" "  ${RESET}: $LAST_EXECUTION_MESSAGE"
echo -e "\n\n"

# On vérifie la conf générale de repomanager.conf ainsi que la cohérence des infos dans les fichiers repos.list et repo_spec.conf avant de commencer
checkConf
# Récupération de la conf si celle-ci a été validée par checkConf
getConf

permissions

# Si la mise à jour automatique est activée et qu'une mise à jour est disponible (testée plus haut), alors on mets à jour repomanager
if [ "$UPDATE_AUTO" == "yes" ] && [ "$UPDATE_AVAILABLE" -eq "1" ];then
	update
fi

# Réinitialisation des variables qui aurait pu être utilisées pour la vérif de la conf
REPO_NAME=""
REPO_REALNAME=""
REPO_HOST=""
REPO_RACINE=""
REPO_DIST=""
REPO_SECTION=""
REPO_ENV=""
REPO_DATE=""
REPO_DESCRIPTION=""

# Si on en est là c'est que les vérifications sont passées (checkConf / getConf) et qu'on peut cette fois relire les paramètres pour lancer les opérations
# Relecture des paramètres et lancement des opérations
while [ $# -ge 1 ];do
	case "$1" in
		--help|-help|-h)
            print_help
       	;;
		--tty)
			TTY="1"
		;;
		--no-tty|--web)
			TTY="0"
		;;
		--repo|--list-repos|-r)
        	listRepo
	    	clean_exit
    	;;
		--archrepo|--list-archived-repos|-ar)
			listOldRepo
			clean_exit
		;;
		--check|-c) # Vérifie la conf (checkConf ci-dessus) et quittes le programme
	    	clean_exit
    	;;
		--planReminders)
			planReminders
			clean_exit
		;;
		--check-update|-cu)
			checkUpdate
			clean_exit
		;;
		--update|--upgrade|-u)
			update
			clean_exit
		;;
## Paramètres d'opérations ##
		--newRepo)
			shift
			newRepo $*
			break
		;;
        --updateRepo)
            shift
    		updateRepo $*
			break
        ;;
        --changeEnv)
            shift
            changeEnv $*
			break
        ;;
		--duplicateRepo)
			shift
			duplicateRepo $*
			break
		;;
		--deleteRepo)
			shift
			deleteRepo $*
			break
		;;
		--deleteDist)
			shift
			deleteDist $*
			break
		;;
		--deleteSection)
			shift
			deleteSection $*
			break
		;;
		--restoreOldRepo)
			shift
			restoreOldRepo $*
			break
		;;
		--deleteOldRepo)
			shift
			deleteOldRepo $*
			break
		;;
		--reset-install)
			rm "$CONF" -f
			install
		;;
		--install)
			install
		;;
		--droits)
			permissions
		;;
		--exec-plan)
			execPlan "$PLAN_ID"
        ;;
       	*)
       	echo "Unknown argument: $1"
       	print_help
       	;;
    esac
	shift
done

cleanArchives

clean_exit