#!/bin/bash

if [ ! -f "$CONF" ];then
	echo -e "\nGénération du fichier de conf"
    touch $CONF
fi


## [CONFIGURATION] ##

echo -e "\n${JAUNE}[ Configuration générale ]${RESET}\n"

# Récupère le PACKAGE_TYPE à partir de $OS_FAMILY
if [ "$OS_FAMILY" == "Debian" ];then PACKAGE_TYPE="deb";fi
if [ "$OS_FAMILY" == "Redhat" ];then PACKAGE_TYPE="rpm";fi

## Alertes mail
# Si le paramètre EMAIL_DEST n'est pas présent ou est vide
if ! grep -q "^EMAIL_DEST=" $CONF || [ -z "$(grep "^EMAIL_DEST=" $CONF | cut -d'=' -f2 | sed 's/"//g')" ];then
	EMAIL_DEST=""
	while [ -z "$EMAIL_DEST" ];do
		echo -ne "➤ Indiquez les adresses mails destinatrices qui recevront les rapports et alertes par mail (séparer les adresses par un espace) : "; read -p "" EMAIL_DEST
	done
else # Sinon on récupère la valeur actuellement présente (car à la fin on va regénèrer complètement le fichier)
	EMAIL_DEST="$(grep "^EMAIL_DEST=" $CONF | cut -d'=' -f2 | sed 's/"//g')"
fi

## Gestion des profils (linuxautoupdate.sh)
# Si le paramètre MANAGE_PROFILES n'est pas présent ou est vide :
if ! grep -q "^MANAGE_PROFILES=" $CONF || [ -z $(grep "^MANAGE_PROFILES=" $CONF | cut -d'=' -f2 | sed 's/"//g') ];then
	MANAGE_PROFILES=""
	while [ -z "$MANAGE_PROFILES" ] || [[ "$MANAGE_PROFILES" != "y" && "$MANAGE_PROFILES" != "n" ]];do
		echo -ne "➤ Activer la gestion des profils pour linuxautoupdate.sh (y/n) : "; read -p "" MANAGE_PROFILES
	done
else # Sinon on récupère la valeur actuellement présente (car à la fin on va regénèrer complètement le fichier)
	MANAGE_PROFILES="$(grep "^MANAGE_PROFILES=" $CONF | cut -d'=' -f2 | sed 's/"//g')"
fi

# Préfix des fichiers de conf de repo
# Si MANAGE_PROFILES est activé, alors on récupère le préfix des fichiers de conf .repo / .list :
if [ "$MANAGE_PROFILES" == "y" ] || [ $(grep "^MANAGE_PROFILES=" $CONF | cut -d'=' -f2 | sed 's/"//g') == "yes" ];then
	if ! grep -q "^REPO_CONF_FILES_PREFIX=" $CONF || [ -z $(grep "^REPO_CONF_FILES_PREFIX=" $CONF | cut -d'=' -f2 | sed 's/"//g') ];then
		REPO_CONF_FILES_PREFIX=""
		if [ "$OS_FAMILY" == "Redhat" ];then echo -ne "➤ Vous pouvez indiquer un préfix aux fichiers de configuration .repo qui seront générés par repomanager (laisser vide pour ne pas ajouter de préfix) : "; read -p "" REPO_CONF_FILES_PREFIX;fi
		if [ "$OS_FAMILY" == "Debian" ];then echo -ne "➤ Vous pouvez indiquer un préfix aux fichiers de configuration .list qui seront générés par repomanager (laisser vide pour ne pas ajouter de préfix) : "; read -p "" REPO_CONF_FILES_PREFIX;fi
	else
		REPO_CONF_FILES_PREFIX="$(grep "^REPO_CONF_FILES_PREFIX=" $CONF | cut -d'=' -f2 | sed 's/"//g')"
	fi
fi

#### Spécifique Redhat ####
if [ "$OS_FAMILY" == "Redhat" ];then

## Releasever ##
	# Si le paramètre RELEASEVER n'est pas présent ou est vide :
	if ! grep -q "^RELEASEVER=" $CONF || [ -z $(grep "^RELEASEVER=" $CONF | cut -d'=' -f2 | sed 's/"//g') ];then
		RELEASEVER=""
		while [ -z "$RELEASEVER" ];do
			echo -ne "➤ Version de paquets CentOS que ce serveur doit synchroniser (7, 8, ...) : "; read -p "" RELEASEVER
		done
	else # Sinon on récupère la valeur actuellement présente (car à la fin on va regénèrer complètement le fichier)
		RELEASEVER="$(grep "^RELEASEVER=" $CONF | cut -d'=' -f2 | sed 's/"//g')"
	fi

## Clé GPG ##
	# Si le paramètre GPG_SIGN_PACKAGES n'est pas présent ou est vide :
	if ! grep -q "^GPG_SIGN_PACKAGES=" $CONF || [ -z $(grep "^GPG_SIGN_PACKAGES=" $CONF | cut -d'=' -f2 | sed 's/"//g') ];then
		GPG_SIGN_PACKAGES=""
		while [ -z "$GPG_SIGN_PACKAGES" ] || [[ "$GPG_SIGN_PACKAGES" != "y" && "$GPG_SIGN_PACKAGES" != "n" ]];do
			echo -ne "➤ Signer les paquets avec GPG (y/n) : "; read -p "" GPG_SIGN_PACKAGES
		done
	else # Sinon on récupère la valeur actuellement présente (car à la fin on va regénèrer complètement le fichier)
		GPG_SIGN_PACKAGES="$(grep "^GPG_SIGN_PACKAGES=" $CONF | cut -d'=' -f2 | sed 's/"//g')"
	fi

	# Si on signe les paquets avec gpg, alors on récupère sa clé gpg
	if [ "$GPG_SIGN_PACKAGES" == "y" ] || [ $(grep "^GPG_SIGN_PACKAGES=" $CONF | cut -d'=' -f2 | sed 's/"//g') == "yes" ];then
		if [ ! -d "$GPGHOME" ] || [ ! -d "${GPGHOME}/private-keys-v1.d/" ];then
			mkdir -p "$GPGHOME"
			mkdir -p "${GPGHOME}/private-keys-v1.d/" # Il faut créer le sous-répertoire private-keys-v1.d/ si il n'existe pas, sinon gpg gueule
		fi 

		# Si le paramètre GPG_KEYID n'est pas présent ou est vide :
		if ! grep -q "^GPG_KEYID=" $CONF || [ -z $(grep "^GPG_KEYID=" $CONF | cut -d'=' -f2 | sed 's/"//g') ];then
			echo -ne "➤ Avez vous déjà une clé GPG pour signer les paquets ? Si oui, tapez [ENTREE] afin d'afficher les clés. Sinon tapez n afin de lancer la procédure de génération : "; read -p "" CONFIRM
			if [ "$CONFIRM" == "" ];then # On affiche les clés GPG, la suite continue plus bas
				gpg2 --homedir ${GPGHOME} --no-permission-warning --list-key 2>/dev/null # on redirige les warnings vers /dev/null pour ne pas polluer l'affichage
				GPG_KEYID=""
				while [ -z "$GPG_KEYID" ];do
					echo -ne "➤ Email lié à la clé GPG servant à signer les paquets : "; read -p "" GPG_KEYID
				done
				PASSPHRASE=""
				while [ -z "$PASSPHRASE" ];do
					echo -ne "➤ Passphrase de la clé GPG : "; read -s PASSPHRASE
				done

			elif [ "$CONFIRM" == "n" ];then
				echo -e "Génération d'une nouvelle clé GPG"
				echo -e "${JAUNE}Vous devez renseigner toutes les infos demandées${RESET}"
				# Initialisation de variables utilisées pour générer la clé GPG
				key_length="";key_name="";key_description="";key_email="";key_passphrase=""

				# On demande les informations pour la génération de la clé
				echo -ne "➤ Taille de clé (1024 / 2048 / 4096) : "; read -p "" key_length
				echo -ne "➤ Nom : "; read -p "" key_name
				echo -ne "➤ Description : "; read -p "" key_description
				echo -ne "➤ Email : "; read -p "" key_email
				echo -ne "➤ Passphrase : "; read -s key_passphrase
				echo ""
				mkdir -p "$GPGHOME" &&
				cd "$GPGHOME" &&
				echo "Key-Type: RSA
	Key-Length: $key_length
	Subkey-Type: RSA
	Subkey-Length: $key_length
	Name-Real: $key_name
	Name-Comment: $key_description
	Name-Email: $key_email
	Expire-Date: 0
	Passphrase: $key_passphrase" > gpg-template-file &&
				gpg2 --batch --gen-key --homedir ${GPGHOME} --no-permission-warning gpg-template-file 2>/dev/null && # on redirige les warnings vers /dev/null pour ne pas polluer l'affichage
				echo -e "Génération de la clé GPG [$VERT OK $RESET]\n" &&
				rm -f gpg-template-file
				GPG_KEYID="$key_email"
				PASSPHRASE="$key_passphrase"
			fi
		else # Sinon on récupère la valeur actuellement présente (car à la fin on va regénèrer complètement le fichier)
			GPG_KEYID="$(grep "^GPG_KEYID=" $CONF | cut -d'=' -f2 | sed 's/"//g')"
		fi

		# Si le fichier de passphrase n'est pas présent ou est vide, on demande la passphrase
		if [ ! -f "$PASSPHRASE_FILE" ] || [ ! -s "$PASSPHRASE_FILE" ];then
			PASSPHRASE=""
			while [ -z "$PASSPHRASE" ];do
				echo -ne "➤ Passphrase de la clé GPG : "; read -s PASSPHRASE
			done
		else
			PASSPHRASE="$(cat $PASSPHRASE_FILE)"
		fi
	fi

	## Rpmmacros ## à voir si c'est toujours utile
	# On injecte l'email du propriétaire de la clé dans le fichier .rpmmacros (utilisé par rpmresign)
#	if [ ! -f "$RPMMACROS" ];then
#		if [ -z "$key_email" ];then # Si la clé GPG existe déjà et qu'on n'est pas passé par l'utilitaire de génération, on demande l'info à l'utilisateur
#			echo -ne "➤ Email lié à la clé GPG servant à signer les paquets : ";read -p "" key_email
#		fi
#			echo "%_gpg_name <${key_email}>" > $RPMMACROS
#	fi
	## Fichier de conf yum "yum.repos.d/repomanager/repomanager.conf"
	if [ ! -f "${REPOMANAGER_YUM_DIR}/repomanager.conf" ];then
		mkdir -p "${REPOMANAGER_YUM_DIR}"
		echo "[main]
reposdir=${REPOMANAGER_YUM_DIR}/
keepcache=0
debuglevel=2
#logfile=${REPOMANAGER_YUM_DIR}/repomanager.log
exactarch=1
obsoletes=1
gpgcheck=1
plugins=1
installonly_limit=5
distroverpkg=centos-release" > /etc/yum.repos.d/repomanager/repomanager.conf
	fi
fi

# Mises à jour
# Si le paramètre UPDATE_AUTO n'est pas présent ou est vide, on le set par défaut à 'yes'
if ! grep -q "^UPDATE_AUTO=" $CONF || [ -z $(grep "^UPDATE_AUTO=" $CONF | cut -d'=' -f2 | sed 's/"//g') ];then
	UPDATE_AUTO="yes"
else # Sinon on récupère la valeur actuellement présente (car à la fin on va regénèrer complètement le fichier)
	UPDATE_AUTO="$(grep "^UPDATE_AUTO=" $CONF | cut -d'=' -f2 | sed 's/"//g')"
fi

# Si le paramètre UPDATE_BACKUP n'est pas présent ou est vide, on le set par défaut à 'yes'
if ! grep -q "^UPDATE_BACKUP=" $CONF || [ -z $(grep "^UPDATE_BACKUP=" $CONF | cut -d'=' -f2 | sed 's/"//g') ];then
	UPDATE_BACKUP="yes"
else # Sinon on récupère la valeur actuellement présente (car à la fin on va regénèrer complètement le fichier)
	UPDATE_BACKUP="$(grep "^UPDATE_BACKUP=" $CONF | cut -d'=' -f2 | sed 's/"//g')"
fi

# Si le paramètre UPDATE_BACKUP_DIR n'est pas présent ou est vide, on le set par défaut à '${BASE_DIR}/backups'
if ! grep -q "^UPDATE_BACKUP_DIR=" $CONF || [ -z $(grep "^UPDATE_BACKUP_DIR=" $CONF | cut -d'=' -f2 | sed 's/"//g') ];then
	UPDATE_BACKUP_DIR="${BASE_DIR}/backups"
else # Sinon on récupère la valeur actuellement présente (car à la fin on va regénèrer complètement le fichier)
	UPDATE_BACKUP_DIR="$(grep "^UPDATE_BACKUP_DIR=" $CONF | cut -d'=' -f2 | sed 's/"//g')"
fi

## Config web
# Si le paramètre WWW_ENABLED n'est pas présent ou est vide
if ! grep -q "^WWW_ENABLED=" $CONF || [ -z $(grep "^WWW_ENABLED=" $CONF | cut -d'=' -f2 | sed 's/"//g') ];then
	WWW_ENABLED=""
	while [ -z "$WWW_ENABLED" ] || [[ "$WWW_ENABLED" != "y" && "$WWW_ENABLED" != "n" ]];do
		echo -ne "➤ Activer le module web (interface web pour repomanager), (un serveur web doit être installé) (y/n) : "; read -p "" WWW_ENABLED
	done
else # Sinon on récupère la valeur actuellement présente (car à la fin on va regénèrer complètement le fichier)
	WWW_ENABLED="$(grep "^WWW_ENABLED=" $CONF | cut -d'=' -f2 | sed 's/"//g')"
fi


## Utilisateur web
# Si WWW_ENABLED est activé, alors on récupère l'utilisateur web (nginx, www-data...) :
if [ "$WWW_ENABLED" == "y" ] || [ $(grep "^WWW_ENABLED=" $CONF | cut -d'=' -f2 | sed 's/"//g') == "yes" ];then

	# Si le paramètre WWW_USER n'est pas présent ou est vide :
	if ! grep -q "^WWW_USER=" $CONF || [ -z $(grep "^WWW_USER=" $CONF | cut -d'=' -f2 | sed 's/"//g') ];then
		if cat /etc/passwd | grep -q "nginx";then
			WWW_USER="nginx"
		elif cat /etc/passwd | grep -q "www-data";then
			WWW_USER="www-data"
		elif cat /etc/passwd | grep -q "apache";then
			WWW_USER="apache"
		elif cat /etc/passwd | egrep "^nginx:|^www-data:|^apache:";then
			echo -ne "➤ ${JAUNE}Plusieurs utilisateurs web ont été détectés, merci de renseigner l'utilisateur principal : ${RESET}"; WWW_USER
		else
			echo -ne "➤ ${JAUNE}Aucun utilisateur web n'a été détecté, merci de renseigner l'utilisateur principal : ${RESET}"; WWW_USER
		fi
	else # Sinon on récupère la valeur actuellement présente (car à la fin on va regénèrer complètement le fichier)
		WWW_USER="$(grep "^WWW_USER=" $CONF | cut -d'=' -f2 | sed 's/"//g')"
	fi
fi

## Host web
# Si WWW_ENABLED est activé, alors on récupère le nom d'hôte web
if [ "$WWW_ENABLED" == "y" ] || [ $(grep "^WWW_ENABLED=" $CONF | cut -d'=' -f2 | sed 's/"//g') == "yes" ];then
	
	# Si le paramètre WWW_HOSTNAME n'est pas présent ou est vide :
	if ! grep -q "^WWW_HOSTNAME=" $CONF || [ -z $(grep "^WWW_HOSTNAME=" $CONF | cut -d'=' -f2 | sed 's/"//g') ];then
		# WWW_HOSTNAME = le nom d'hôte de la machine si celui-ci est bien paramétré. Si ce n'est pas le cas (vide) alors on le demande
		WWW_HOSTNAME="$HOSTNAME"
		while [ -z "$WWW_HOSTNAME" ];do
			echo -ne "➤ Indiquez le nom d'hôte de ce serveur : "; read -p "" WWW_HOSTNAME
		done
	else # Sinon on récupère la valeur actuellement présente (car à la fin on va regénèrer complètement le fichier)
		WWW_HOSTNAME="$(grep "^WWW_HOSTNAME=" $CONF | cut -d'=' -f2 | sed 's/"//g')"
	fi
fi

# Si le paramètre WWW_REPOS_DIR_URL n'est pas présent ou est vide :
if ! grep -q "^WWW_REPOS_DIR_URL=" $CONF || [ -z $(grep "^WWW_REPOS_DIR_URL=" $CONF | cut -d'=' -f2 | sed 's/"//g') ];then
	WWW_REPOS_DIR_URL=""
	while [ -z "$WWW_REPOS_DIR_URL" ];do
		echo -ne "➤ Indiquez l'url d'accès au répertoire des repos (${REPOS_DIR}), configurée dans votre vhost : https://"; read -p "" WWW_REPOS_DIR_URL
	done
	# On reforge la variable en ajoutant https:// devant :
	WWW_REPOS_DIR_URL="https://${WWW_REPOS_DIR_URL}"
else # Sinon on récupère la valeur actuellement présente (car à la fin on va regénèrer complètement le fichier)
	WWW_REPOS_DIR_URL="$(grep "^WWW_REPOS_DIR_URL=" $CONF | cut -d'=' -f2 | sed 's/"//g')"
fi


## Environnements
echo -e "\n${JAUNE}[ Environnements ]${RESET}\n"

# Si la section [ENVIRONNEMENTS] n'est pas présente ou est vide
if ! grep -q "^\[ENVIRONNEMENTS]" $ENV_CONF || [ -z "$(cat $ENV_CONF | grep -v '\[ENVIRONNEMENTS\]')" ];then
	i="0";newenv="null";totalenv=""

	echo -e "Indiquez autant d'environnements de tests que nécessaire. Un environnement prod sera automatiquement ajouté en dernier :"
	while [ ! -z "$newenv" ];do
		echo -ne "➤ Environnement $i (laisser vide pour passer à la suite) : "; read -p "" newenv
		totalenv="$totalenv\n${newenv}"
		(( i++ ))
	done
	totalenv="${totalenv}prod";totalenv=$(echo -e $totalenv | sed '/^$/d')
	# On affiche tout pour demander confirmation :
	echo -e "\nEnvironnements :"
	echo -e "$totalenv"
	DEFAULT_ENV=$(echo -e "$totalenv" | head -n1)
	echo -e "L'environnement par défaut (bas de la chaine) sera ${JAUNE}${DEFAULT_ENV}${RESET}"
	echo -ne "➤ Confirmer (y/n) : "; read -p "" CONFIRM
	if [ "$CONFIRM" != "y" ];then
		clean_exit
	fi
else # Sinon on récupère la valeur actuellement présente (car à la fin on va regénèrer complètement le fichier)
	totalenv="$(cat $ENV_CONF | grep -v '\[ENVIRONNEMENTS\]')"
	DEFAULT_ENV=$(echo -e "$totalenv" | head -n1)
fi


## Automatisation
echo -e "\n${JAUNE}[ Automatisation ]${RESET}\n"

# Si le paramètre AUTOMATISATION_ENABLED n'est pas présent ou est vide :
if ! grep -q "^AUTOMATISATION_ENABLED=" $CONF || [ -z $(grep "^AUTOMATISATION_ENABLED=" $CONF | cut -d'=' -f2 | sed 's/"//g') ];then
	AUTOMATISATION_ENABLED=""
	while [ -z "$AUTOMATISATION_ENABLED" ] || [[ "$AUTOMATISATION_ENABLED" != "y" && "$AUTOMATISATION_ENABLED" != "n" ]];do
		echo -ne "➤ Activer l'automatisation ? (y/n) : "; read -p "" AUTOMATISATION_ENABLED
	done
else # Sinon on récupère la valeur actuellement présente (car à la fin on va regénèrer complètement le fichier)
	AUTOMATISATION_ENABLED="$(grep "^AUTOMATISATION_ENABLED=" $CONF | cut -d'=' -f2 | sed 's/"//g')"
fi

# Si l'automatisation est activée, alors on récupère ses sous-paramètres
if [ "$AUTOMATISATION_ENABLED" == "y" ] || [ $(grep "^AUTOMATISATION_ENABLED=" $CONF | cut -d'=' -f2 | sed 's/"//g') == "yes" ];then

	# Autoriser la mise à jour auto des repos
	if ! grep -q "^ALLOW_AUTOUPDATE_REPOS=" $CONF || [ -z $(grep "^ALLOW_AUTOUPDATE_REPOS=" $CONF | cut -d'=' -f2 | sed 's/"//g') ];then
		ALLOW_AUTOUPDATE_REPOS=""
		while [ -z "$ALLOW_AUTOUPDATE_REPOS" ] || [[ "$ALLOW_AUTOUPDATE_REPOS" != "y" && "$ALLOW_AUTOUPDATE_REPOS" != "n" ]];do
			echo -ne "➤ Autoriser la mise à jour automatique des repos ? (y/n) : "; read -p "" ALLOW_AUTOUPDATE_REPOS
		done
	else # Sinon on récupère la valeur actuellement présente (car à la fin on va regénèrer complètement le fichier)
		ALLOW_AUTOUPDATE_REPOS="$(grep "^ALLOW_AUTOUPDATE_REPOS=" $CONF | cut -d'=' -f2 | sed 's/"//g')"
	fi

	# Autoriser la mise à jour auto de l'env des repos (ex: passer de test à prod automatiquement)
	if ! grep -q "^ALLOW_AUTOUPDATE_REPOS_ENV=" $CONF || [ -z $(grep "^ALLOW_AUTOUPDATE_REPOS_ENV=" $CONF | cut -d'=' -f2 | sed 's/"//g') ];then
		ALLOW_AUTOUPDATE_REPOS_ENV=""
		while [ -z "$ALLOW_AUTOUPDATE_REPOS_ENV" ] || [[ "$ALLOW_AUTOUPDATE_REPOS_ENV" != "y" && "$ALLOW_AUTOUPDATE_REPOS_ENV" != "n" ]];do
			echo -ne "➤ Autoriser la mise à jour automatique de l'env des repos ? (y/n) : "; read -p "" ALLOW_AUTOUPDATE_REPOS_ENV
		done
	else # Sinon on récupère la valeur actuellement présente (car à la fin on va regénèrer complètement le fichier)
		ALLOW_AUTOUPDATE_REPOS_ENV="$(grep "^ALLOW_AUTOUPDATE_REPOS_ENV=" $CONF | cut -d'=' -f2 | sed 's/"//g')"
	fi

	# Configuration du nettoyage auto
	if ! grep -q "^ALLOW_AUTODELETE_ARCHIVED_REPOS=" $CONF || [ -z $(grep "^ALLOW_AUTODELETE_ARCHIVED_REPOS=" $CONF | cut -d'=' -f2 | sed 's/"//g') ];then
		ALLOW_AUTODELETE_ARCHIVED_REPOS=""
		while [ -z "$ALLOW_AUTODELETE_ARCHIVED_REPOS" ] || [[ "$ALLOW_AUTODELETE_ARCHIVED_REPOS" != "y" && "$ALLOW_AUTODELETE_ARCHIVED_REPOS" != "n" ]];do
			echo -ne "➤ Activer le nettoyage automatique des anciens repos archivés (suppression) ? (y/n) : "; read -p "" ALLOW_AUTODELETE_ARCHIVED_REPOS
		done
	else # Sinon on récupère la valeur actuellement présente (car à la fin on va regénèrer complètement le fichier)
		ALLOW_AUTODELETE_ARCHIVED_REPOS="$(grep "^ALLOW_AUTODELETE_ARCHIVED_REPOS=" $CONF | cut -d'=' -f2 | sed 's/"//g')"
	fi

	# Si le nettoyage auto est activé
	if [ "$ALLOW_AUTODELETE_ARCHIVED_REPOS" == "y" ] || [ $(grep "^ALLOW_AUTODELETE_ARCHIVED_REPOS=" $CONF | cut -d'=' -f2 | sed 's/"//g') == "yes" ];then
		if ! grep -q "^RETENTION=" $CONF || [ -z $(grep "^RETENTION=" $CONF | cut -d'=' -f2 | sed 's/"//g') ];then
			RETENTION=""
			while [ -z "$RETENTION" ];do
				echo -ne "➤ Nombre de repos archivés à conserver avant suppression définitive (retention) : "; read -p "" RETENTION
			done
		else # Sinon on récupère la valeur actuellement présente (car à la fin on va regénèrer complètement le fichier)
			RETENTION="$(grep "^RETENTION=" $CONF | cut -d'=' -f2 | sed 's/"//g')"
		fi
	else
		RETENTION=""
	fi

# Si l'automatisation n'est pas activée, alors on passe tous ses sous-paramètres à "no"
else
	ALLOW_AUTOUPDATE_REPOS="no"
	ALLOW_AUTOUPDATE_REPOS_ENV="no"
	ALLOW_AUTODELETE_ARCHIVED_REPOS="no"
	RETENTION=""
fi


#### Génération du fichier de conf ####
#### Ajout de toutes les infos récupérées précédemment, dans le fichier de conf ####

echo -e "# Fichier de configuration de repomanager\n" > "$CONF"

# Configuration générale
echo "[CONFIGURATION]" >> "$CONF"

# Ajout du type de paquets que ce serveur gérera 
echo "PACKAGE_TYPE=\"$PACKAGE_TYPE\"" >> "$CONF"

# Config Releasever
if [ "$OS_FAMILY" == "Redhat" ];then
	echo "RELEASEVER=\"$RELEASEVER\"" >> "$CONF"
fi

# Destinataires mails
echo "EMAIL_DEST=\"${EMAIL_DEST}\"" >> "$CONF"

# Gestion des profils pour linux-autoupdate.sh
if [ "$MANAGE_PROFILES" == "yes" ] || [ "$MANAGE_PROFILES" == "y" ];then
	echo "MANAGE_PROFILES=\"yes\"" >> "$CONF"
	echo "REPO_CONF_FILES_PREFIX=\"${REPO_CONF_FILES_PREFIX}\"" >> "$CONF"
else
	echo "MANAGE_PROFILES=\"no\"" >> "$CONF"
	echo "REPO_CONF_FILES_PREFIX=\"\"" >> "$CONF"
fi

# Config GPG (Centos seulement)
if [ "$OS_FAMILY" == "Redhat" ];then
	echo -e "\n[GPG]" >> "$CONF"
	if [ "$GPG_SIGN_PACKAGES" == "yes" ] || [ "$GPG_SIGN_PACKAGES" == "y" ];then
		echo "GPG_SIGN_PACKAGES=\"yes\"" >> "$CONF"
		echo "GPG_KEYID=\"$GPG_KEYID\"" >> "$CONF"
		echo "$PASSPHRASE" > "$PASSPHRASE_FILE"
		gpg2 --no-permission-warning --homedir "$GPGHOME" --export -a "$GPG_KEYID" > ${REPOS_DIR}/${WWW_HOSTNAME}.pub 2>/dev/null # on redirige les warnings vers /dev/null pour ne pas polluer l'affichage		
	else
		echo "GPG_SIGN_PACKAGES=\"no\"" >> "$CONF"
	fi
fi

# Mise à jour
echo -e "\n[UPDATE]" >> "$CONF"
echo "UPDATE_AUTO=\"${UPDATE_AUTO}\"" >> "$CONF"
echo "UPDATE_BACKUP=\"${UPDATE_BACKUP}\"" >> "$CONF"
echo "UPDATE_BACKUP_DIR=\"${UPDATE_BACKUP_DIR}\"" >> "$CONF"

# Config web
echo -e "\n[WWW]" >> "$CONF"
echo "WWW_ENABLED=\"yes\"" >> "$CONF"
# Ajout de l'utilisateur web et du nom d'hôte
echo "WWW_USER=\"${WWW_USER}\"" >> "$CONF"
echo "WWW_HOSTNAME=\"${WWW_HOSTNAME}\"" >> "$CONF"
echo "WWW_REPOS_DIR_URL=\"${WWW_REPOS_DIR_URL}\"" >> "$CONF"

# Configuration des environnements
echo -e "[ENVIRONNEMENTS]\n${totalenv}" > "$ENV_CONF"

# Configuration de la partie automatisation
echo -e "\n[AUTOMATISATION]" >> "$CONF"

# Configuration de l'automatisation
if [ "$AUTOMATISATION_ENABLED" == "yes" ] || [ "$AUTOMATISATION_ENABLED" == "y" ];then
	echo -e "AUTOMATISATION_ENABLED=\"yes\"" >> "$CONF"
	if [ "$ALLOW_AUTOUPDATE_REPOS" == "yes" ] || [ "$ALLOW_AUTOUPDATE_REPOS" == "y" ];then
		echo -e "ALLOW_AUTOUPDATE_REPOS=\"yes\"" >> "$CONF"
	else
		echo -e "ALLOW_AUTOUPDATE_REPOS=\"no\"" >> "$CONF"
	fi
	if [ "$ALLOW_AUTOUPDATE_REPOS_ENV" == "yes" ] || [ "$ALLOW_AUTOUPDATE_REPOS_ENV" == "y" ];then
		echo -e "ALLOW_AUTOUPDATE_REPOS_ENV=\"yes\"" >> "$CONF"
	else
		echo -e "ALLOW_AUTOUPDATE_REPOS_ENV=\"no\"" >> "$CONF"
	fi
	if [ "$ALLOW_AUTODELETE_ARCHIVED_REPOS" == "yes" ] || [ "$ALLOW_AUTODELETE_ARCHIVED_REPOS" == "y" ];then
		echo -e "ALLOW_AUTODELETE_ARCHIVED_REPOS=\"yes\"" >> "$CONF"
		echo -e "RETENTION=\"$RETENTION\"" >> "$CONF"
	else
		echo -e "ALLOW_AUTODELETE_ARCHIVED_REPOS=\"no\"" >> "$CONF"
		echo -e "RETENTION=\"\"" >> "$CONF"
	fi
# Si l'automatisation n'est pas activée, alors on passse tout à "no"
else
	echo -e "AUTOMATISATION_ENABLED=\"no\"" >> "$CONF"
	echo -e "ALLOW_AUTOUPDATE_REPOS=\"no\"" >> "$CONF"
	echo -e "ALLOW_AUTOUPDATE_REPOS_ENV=\"no\"" >> "$CONF"
	echo -e "ALLOW_AUTODELETE_ARCHIVED_REPOS=\"no\"" >> "$CONF"
	echo -e "RETENTION=\"\"" >> "$CONF"
fi

if [ "$OS_FAMILY" == "Redhat" ];then
	# Création du répetoire sui contiendra le cache yum (à voir si c'est toujours utile)
	if [ ! -d "${BASE_DIR}/.cache/yum/" ];then 
		mkdir -p "${BASE_DIR}/.cache/yum/"
	fi

	# Création du fichier RELEASEVER dans lequel on injectera la version des paquets qu'on synchronise sur ce serveur
	if [ ! -f "/etc/yum/vars/RELEASEVER" ];then
		mkdir -p "/etc/yum/vars/"		# On crée le répertoire et le fichier, les droits dessus seront ensuite ajustés par la fonction permissions
		touch /etc/yum/vars/RELEASEVER
	fi
	echo "$RELEASEVER" > /etc/yum/vars/RELEASEVER

	# Création du répertoire contenant les clés gpg importées par repomanager
	if [ ! -d "$RPM_GPG_DIR" ];then
		mkdir -p "$RPM_GPG_DIR" # Création du répertoire, la fonction permissions se chargera de mettre en place les bons droits dessus
	fi
fi

# Création d'un groupe repomanager
if ! grep -q "repomanager" /etc/group;then
	groupadd repomanager
	usermod -G repomanager "$WWW_USER" # l'utilisateur web est intégré au groupe repomanager
fi

# Conf at pour pouvoir créer des planifications
# L'utilisateur web ne doit pas être interdit de créer des tâches at, on le retire de at.deny si il est présent :
if [ -f "/etc/at.deny" ];then
	if grep -q "$WWW_USER" /etc/at.deny;then
		sed -i "/${WWW_USER}/d" /etc/at.deny 
	fi
fi
# L'utilisateur web doit être présent dans /etc/at.allow :
if [ -f "/etc/at.allow" ];then
	if ! grep -q "$WWW_USER" /etc/at.allow;then
		echo "$WWW_USER" >> /etc/at.allow
	fi
fi

# Conf cron pour pouvoir autoriser WWW_USER à modifier sa crontab
if [ -f "/etc/cron.deny" ];then
	if grep -q "$WWW_USER" /etc/cron.deny;then
		sed -i "/${WWW_USER}/d" /etc/cron.deny 
	fi
fi
# L'utilisateur web doit être présent dans /etc/at.allow :
if [ -f "/etc/cron.allow" ];then
	if ! grep -q "$WWW_USER" /etc/cron.allow;then
		echo "$WWW_USER" >> /etc/cron.allow
	fi
fi

# Mise en place des tâches cron si ce n'est pas déjà le cas
# On exporte la crontab actuelle de WWW_USER dans un fichier (si une crontab existe)
if ! sudo -u "$WWW_USER" crontab -l | grep "no crontab for";then
	# Si une crontab existe on l'exporte
	sudo -u "$WWW_USER" crontab -l > "/tmp/${WWW_USER}_crontab.tmp"
else 
	# Sinon on crée un fichier vierge
	touch "/tmp/${WWW_USER}_crontab.tmp"
fi
if [ "$AUTOMATISATION_ENABLED" == "yes" ];then
	# Si la tâche de rappels n'existe pas, alors on la rajoute à la suite du fichier exporté
	if ! grep -q ".*--planReminders" /tmp/${WWW_USER}_crontab.tmp;then
		echo "0 0 * * * bash ${REPOMANAGER} --planReminders" >> /tmp/${WWW_USER}_crontab.tmp
	fi
	# Si la tâche existe mais qu'elle est commentée alors on la décommente
	if grep -q "#.*--planReminders" /tmp/${WWW_USER}_crontab.tmp;then
		sed -i '/#.*--planReminders/d' /tmp/${WWW_USER}_crontab.tmp
		echo "0 0 * * * bash ${REPOMANAGER} --planReminders" >> /tmp/${WWW_USER}_crontab.tmp
	fi
fi
# Si la tâche cron journalière n'existe pas, alors on la rajoute à la suite du fichier exporté
if ! grep -q ".*cronjob-daily" /tmp/${WWW_USER}_crontab.tmp;then
	echo "*/5 * * * * bash ${BASE_DIR}/repomanager --cronjob-daily" >> /tmp/${WWW_USER}_crontab.tmp
fi
# Si la tâche existe mais qu'elle est commentée alors on la décommente
if grep -q "#.*--cronjob-daily" /tmp/${WWW_USER}_crontab.tmp;then
	sed -i '/#.*--cronjob-daily/d' /tmp/${WWW_USER}_crontab.tmp
	echo "*/5 * * * * bash ${BASE_DIR}/repomanager --cronjob-daily" >> /tmp/${WWW_USER}_crontab.tmp
fi

# Enfin on réimporte le fichier dans la crontab de $WWW_USER
crontab -u "$WWW_USER" /tmp/${WWW_USER}_crontab.tmp

# Application des bonnes permissions sur les répertoires et fichiers
permissions