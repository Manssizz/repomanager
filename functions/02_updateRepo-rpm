#!/bin/bash

# La fonction a besoin de 3 paramètre pour fonctionner :
# Le nom du repo 
# Le nom du repo source
# Le check gpg si activé ou non
# La signature des paquets si activée ou non

# Affichage des arguments passés si le mode debug est activé :
if [ "$DEBUG_MODE" == "enabled" ];then echo "Arguments : $@";fi

while [ $# -ge 1 ];do case "$1" in
	--repo-name)
		REPO_NAME="$2"
		shift
	;;
	--repo-real-name)
		REPO_REALNAME="$2"
		shift
	;;
	--gpg-check)
		GPG_CHECK="$2"
		shift
	;;
	--gpg-resign)
		GPG_SIGN_PACKAGES="$2" # on réécrit la variable GPG_SIGN_PACKAGES par ce qui a été transmis
		shift
	;;
	*)
	esac
	shift
done

ERROR="0"

# Si le repo est présent dans le fichier repos.list, alors on peut commencer l'opération
if ! egrep -q "^Name=\"${REPO_NAME}\",Realname=\"${REPO_REALNAME}\",Env=\"${DEFAULT_ENV}\"" $REPOS_LIST;then
	(( ERROR++ ))
	echo -e "\n[${ROUGE} ERREUR ${RESET}] Il n'existe aucun repo ${CYAN}${REPO_NAME}${RESET} sur ce serveur."        
	MSG_MAIN_ERROR="$MSG_MAIN_ERROR\n Erreur : Il n'existe aucun repo ${REPO_NAME} sur ce serveur."
	if [ "$PLAN_EXEC" -eq "1" ];then # Si cette tâche est exécutée par une planification, alors il faut incrémenter la variable d'erreur utilisée par la fonction planification
		(( PLAN_ERROR++ ))
	fi
fi

# Si le repo existe déjà à la date du jour alors on annule l'opération
if egrep -q "^Name=\"${REPO_NAME}\",Realname=\"${REPO_REALNAME}\",Env=\"${DEFAULT_ENV}\",Date=\"${DATE_JMA}\"" $REPOS_LIST;then
	(( ERROR++ ))
	echo -e "\n[${ROUGE} ERREUR ${RESET}] Le repo ${REPO_NAME} existe déjà à la date du ${DATE_JMA}."        
	MSG_MAIN_ERROR="$MSG_MAIN_ERROR\n Le repo ${REPO_NAME} existe déjà à la date du ${DATE_JMA}."
	if [ "$PLAN_EXEC" -eq "1" ];then # Si cette tâche est exécutée par une planification, alors il faut incrémenter la variable d'erreur utilisée par la fonction planification
		(( PLAN_ERROR++ ))
	fi
fi


# On traite uniquement si il n'y a pas eu d'erreur précédemment
if [ "$ERROR" -eq "0" ];then
	OLD_DATE_REPO=$(egrep "^Name=\"${REPO_NAME}\",Realname=\"${REPO_REALNAME}\",Env=\"${DEFAULT_ENV}\"" $REPOS_LIST | awk -F ',' '{print $4}' | cut -d'=' -f2 | sed 's/"//g')	# On récupère du coup sa date de synchro

	####

	echo -e "\nDébut de l'opération"
	sleep 2

	####

	echo -ne "Création du répertoire :\t"
	mkdir -p "${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}"
	if [ $? -eq "0" ];then
		echo -e "[${VERT} OK ${RESET}]"
	else
		(( ERROR++ ))
		echo -e "[${ROUGE} ERREUR ${RESET}] Problème lors de la création du répertoire ${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}"
		MSG_MAIN_ERROR="$MSG_MAIN_ERROR\n Problème lors de la création du répertoire ${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}"
		if [ "$PLAN_EXEC" -eq "1" ];then # Si cette tâche est exécutée par une planification, alors il faut incrémenter la variable d'erreur utilisée par la fonction planification
			(( PLAN_ERROR++ ))
		fi
	fi
fi


# On continue uniquement si il n'y a pas eu d'erreur précédemment
if [ "$ERROR" -eq "0" ];then
	echo -e "Récupération des paquets .rpm..."
	sleep 2

	# Lancement du clonage du repo avec reposync, deux cas possibles : 
	if [ "$GPG_CHECK" == "no" ] || [ "$NO_GPG_CHECK" -eq "1" ];then	# Cas où on ne souhaite pas vérifier la signature des paquets du repo à cloner
		if [ "$OS_VERSION" == "7" ];then
			reposync --config=${REPOMANAGER_YUM_DIR}/repomanager.conf -l --repoid=${REPO_REALNAME} --norepopath --download_path=${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}/
			RESULT=$?
		fi
		if [ "$OS_VERSION" == "8" ];then
			reposync --config=${REPOMANAGER_YUM_DIR}/repomanager.conf --nogpgcheck --repoid=${REPO_REALNAME} --download-path "${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}/"
			RESULT=$?
		fi
	else # Dans tous les autres cas (même si rien n'a été précisé) on active gpgcheck
		if [ "$OS_VERSION" == "7" ];then
			reposync --config=${REPOMANAGER_YUM_DIR}/repomanager.conf --gpgcheck -l --repoid=${REPO_REALNAME} --norepopath --download_path=${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}/
			RESULT=$?
		fi
		if [ "$OS_VERSION" == "8" ];then
			reposync --config=${REPOMANAGER_YUM_DIR}/repomanager.conf --repoid=${REPO_REALNAME} --download-path "${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}/"
			RESULT=$?
		fi
	fi
	if [ "$RESULT" -eq "0" ];then
		echo -e "\nCréation du repo ${REPO_NAME} terminé ${VERT}avec succès${RESET}"
	else
		(( ERROR++ ))
		echo -e "[${ROUGE} ERREUR ${RESET}] reposync a rencontré un problème lors de la création du miroir"
		MSG_MAIN_ERROR="$MSG_MAIN_ERROR\n reposync a rencontré un problème lors de la création du miroir"
		if [ "$PLAN_EXEC" -eq "1" ];then # Si cette tâche est exécutée par une planification, alors il faut incrémenter la variable d'erreur utilisée par la fonction planification
			(( PLAN_ERROR++ ))
		fi
		echo -ne "Suppression de ce qui a été fait : "
		rm ${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}/ -rf &&
		echo -e "[${VERT} OK ${RESET}]"
	fi
fi

# On continue uniquement si il n'y a pas eu d'erreur précédemment
if [ "$ERROR" -eq "0" ];then
	if [ "$GPG_SIGN_PACKAGES" == "yes" ];then
		echo -e "\nSignature des paquets .rpm :"
		cd ${REPOS_DIR}/"${DATE_JMA}_${REPO_NAME}"/ &&	# On se mets à la racine du repo
		shopt -s globstar # Activation de globstar (**), cela permet à bash d'aller chercher des fichiers .rpm récursivement, peu importe le nb de sous-répertoires
		if [ -f "/usr/bin/rpmresign" ];then
			/usr/bin/rpmresign  --path ${GPGHOME} --name ${GPG_KEYID} --passwordfile ${PASSPHRASE_FILE} **/*.rpm
			RESULT=$?
		else
			rpmsign --addsign **/*.rpm	# Sinon on utilise rpmsign et on demande le mdp à l'utilisateur (pas possible d'utiliser un fichier passphrase)
			RESULT=$?
		fi
		if [ "$RESULT" -eq "0" ];then
			shopt -u globstar && # Désactivation de globstar
			echo -e "\nPaquets signés ${VERT}avec succès${RESET}"
		else
			(( ERROR++ ))
			echo -e "[${ROUGE} ERREUR ${RESET}] La signature des paquets a rencontré une erreur"
			MSG_MAIN_ERROR="$MSG_MAIN_ERROR\n La signature des paquets a rencontré une erreur"
			if [ "$PLAN_EXEC" -eq "1" ];then # Si cette tâche est exécutée par une planification, alors il faut incrémenter la variable d'erreur utilisée par la fonction planification
				(( PLAN_ERROR++ ))
			fi
			echo -ne "Suppression de ce qui a été fait : "
			rm ${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}/ -rf &&
			echo -e "[${VERT} OK ${RESET}]"
		fi
	fi
fi

# On continue uniquement si il n'y a pas eu d'erreur précédemment
if [ "$ERROR" -eq "0" ];then
	# Création du repo (fabrique un fichier metadata .xml) :
	echo -e "\nCréation du dépôt :"
	createrepo -v ${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}/
	if [ $? -eq "0" ];then
		echo -e "\nMise à jour du repo ${REPO_NAME} terminée ${VERT}avec succès${RESET}"
	else
		(( ERROR++ ))
		echo -e "[${ROUGE} ERREUR ${RESET}] lors de la création du repo"
		MSG_MAIN_ERROR="$MSG_MAIN_ERROR\n Erreur lors de la création du repo"
		if [ "$PLAN_EXEC" -eq "1" ];then # Si cette tâche est exécutée par une planification, alors il faut incrémenter la variable d'erreur utilisée par la fonction planification
			(( PLAN_ERROR++ ))
		fi
		echo -ne "Suppression de ce qui a été fait : "
		rm ${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}/ -rf &&
		echo -e "[${VERT} OK ${RESET}]"
	fi
fi

# On continue uniquement si il n'y a pas eu d'erreur précédemment
if [ "$ERROR" -eq "0" ];then
	echo -ne "Création du lien symbolique :\t\t"
	cd ${REPOS_DIR}/ &&
	unlink ${REPO_NAME}_${DEFAULT_ENV} # Supression du lien symbolique pointant sur l'ancienne version du repo
	ln -sf ${DATE_JMA}_${REPO_NAME}/ ${REPO_NAME}_${DEFAULT_ENV}
	if [ $? -eq "0" ];then
		echo -e "[${VERT} OK ${RESET}]"
	else
		(( ERROR++ ))
		echo -e "[${ROUGE} ERREUR ${RESET}] pendant la création du lien symbolique"
		MSG_MAIN_ERROR="$MSG_MAIN_ERROR\n Erreur pendant la création du lien symbolique"
		if [ "$PLAN_EXEC" -eq "1" ];then # Si cette tâche est exécutée par une planification, alors il faut incrémenter la variable d'erreur utilisée par la fonction planification
			(( PLAN_ERROR++ ))
		fi
	fi
fi

# On continue uniquement si il n'y a pas eu d'erreur précédemment
if [ "$ERROR" -eq "0" ];then
	if ! egrep "^Name=\"${REPO_NAME}\",Realname=\".*\",Env=\".*\",Date=\"${OLD_DATE_REPO}\"" $REPOS_LIST | grep -v -q "Env=\"${DEFAULT_ENV}\"";then
		echo "La version précédente du ${OLD_DATE_REPO} n'est pas utilisée par d'autres environnements (donc elle n'est plus utilisée)"
		OLD_DESCRIPTION=$(egrep "^Name=\"${REPO_NAME}\",Realname=\".*\",Env=\"${DEFAULT_ENV}\"" "$REPOS_LIST" | awk -F',' '{print $5}' | cut -d'=' -f2 | sed 's/"//g')
		OLD_REALNAME=$(egrep "^Name=\"${REPO_NAME}\",Realname=\".*\",Env=\"${DEFAULT_ENV}\"" "$REPOS_LIST" | awk -F',' '{print $2}' | cut -d'=' -f2 | sed 's/"//g') # on récupère aussi l'ancien hote au cas où il soit différent 
		echo -ne "Archivage de l'ancienne version :\t"
		cd ${REPOS_DIR}/ &&
		mv "${OLD_DATE_REPO}_${REPO_NAME}/" "archived_${OLD_DATE_REPO}_${REPO_NAME}/" # On renomme l'ancienne version en tant que old_prod_JJ-MM-AAAA_base/
		echo -e "[${VERT} OK ${RESET}]"
		echo -ne "Mise à jour des informations dans repos-archive.list :\t"
		echo "Name=\"${REPO_NAME}\",Realname=\"${OLD_REALNAME}\",Date=\"${OLD_DATE_REPO}\",Description=\"${OLD_DESCRIPTION}\"" >> $REPOS_ARCHIVE_LIST
		echo -e "[${VERT} OK ${RESET}]"
	fi

	####

	echo -ne "Mise à jour des informations dans repos.list :\t" &&
	sed -i "s|^Name=\"${REPO_NAME}\",Realname=\".*\",Env=\"${DEFAULT_ENV}\",Date=\"${OLD_DATE_REPO}\"|Name=\"${REPO_NAME}\",Realname=\"${REPO_REALNAME}\",Env=\"${DEFAULT_ENV}\",Date=\"${DATE_JMA}\"|g" $REPOS_LIST &&  # On mets à jour les infos dans le fichier repos.list (par exemple)
	if [ $? -eq "0" ];then
		echo -e "[${VERT} OK ${RESET}]"
	else
		(( ERROR++ ))
		echo -e "[${ROUGE} ERREUR ${RESET}] pendant l'ajout des informations"
		MSG_MAIN_ERROR="$MSG_MAIN_ERROR\n Erreur pendant l'ajout des informations"
		if [ "$PLAN_EXEC" -eq "1" ];then # Si cette tâche est exécutée par une planification, alors il faut incrémenter la variable d'erreur utilisée par la fonction planification
			(( PLAN_ERROR++ ))
		fi
	fi
fi

# On continue uniquement si il n'y a pas eu d'erreur précédemment
if [ "$ERROR" -eq "0" ];then
	echo -ne "Application des droits sur le repo créé :\t"
	find ${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}/ -type f -exec chmod 0660 {} \; &&
	find ${REPOS_DIR}/${DATE_JMA}_${REPO_NAME}/ -type d -exec chmod 0770 {} \; &&
	echo -e "[${VERT} OK ${RESET}]"

	echo -e "${VERT}Opération terminée${RESET}"
fi