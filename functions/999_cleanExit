#!/bin/bash
# Nettoyage, envoi des mails éventuels avant de quitter le programme

# Retour au répertoire de base, pour ne pas empêcher un quelconque nettoyage de répertoire
cd "$BASE_DIR"

# En mode auto (planification), on concatene tous les messages d'erreurs rencontrés dans 1 message global afin de l'envoyer par mail :
if [ "$TTY" -eq "0" ];then
	# On commence par les messages d'erreur de conf
	if [ ! -z "$MSG_CHECK_CONF_ERROR" ];then
		MSG_MAIN="${MSG_MAIN}\nErreur lors de la vérification de la configuration :\n${MSG_CHECK_CONF_ERROR}"
	fi

	# Messages d'erreur lors du traitement d'une opération
	if [ ! -z "$MSG_MAIN_ERROR" ];then
		MSG_MAIN="${MSG_MAIN}\nErreur lors du traitement :\n${MSG_MAIN_ERROR}"
	fi

	# Messages d'erreur des planifications
	if [ ! -z "$MSG_PLAN_ERROR" ];then
		MSG_MAIN="${MSG_MAIN}\nErreur lors du traitement de la planification :\n${MSG_PLAN_ERROR}"
	fi

	# Si des anciens repos ont été supprimés, on envoi un mail
	if [ ! -z "$MSG_DELETE_ARCHIVED_REPOS_AUTO" ];then
		sendMail
	fi

	# Du coup si on a un message global, on l'affiche à l'écran pour qu'il soit affiché dans le log et on envoie un mail
	if [ ! -z "$MSG_MAIN" ];then
		sendMail
	fi
fi

# On tri le contenu des fichiers de listes
sortLists

# On réapplique les droits afin qu'ils soient d'aplomb pour la prochaine exécution
permissions

# Suppression du script d'installation
rm "${BASE_DIR}"/install -f

# Suppression du répertoire de mise à jour si une mise à jour a eu lieu
rm "${BASE_DIR}"/update -fr

# Suppression des fichiers ignore si il y en a
rm "${BASE_DIR}"/.*ignore -fr

# On supprime le fichier de log si KEEP_LOG != yes
if [ "$KEEP_LOG" != "yes" ];then
	rm "$LOG" -f
fi

# Suppression des fichiers temporaires utilisés pendant l'opération
rm /tmp/repomanager* -fr

exit