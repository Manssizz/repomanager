#!/bin/bash

# Si cette fonction est exécutée, c'est que les vérifs des fichiers de conf ont été effectuées avec succès, donc inutile de re-vérifier à nouveau les planifications, on va traiter directement cette fois

echo -e "Traitement de la planification Plan-${PLAN_ID}\n"

# Récupération des détails de la planification actuelle dans le fichier de conf, afin de savoir quels repos sont impliqués et quelle action effectuer
PLAN_ACTION=$(sed -n "/\[Plan-${1}\]/,/\[/p" "$PLAN_CONF_FILE" | grep "^Action=" | cut -d'=' -f2 | sed 's/"//g')
PLAN_REPO_NAME=$(sed -n "/\[Plan-${1}\]/,/\[/p" "$PLAN_CONF_FILE" | grep "^Repo=" | cut -d'=' -f2 | sed 's/"//g')
PLAN_REPO_DIST=$(sed -n "/\[Plan-${1}\]/,/\[/p" "$PLAN_CONF_FILE" | grep "^Dist=" | cut -d'=' -f2 | sed 's/"//g')
PLAN_REPO_SECTION=$(sed -n "/\[Plan-${1}\]/,/\[/p" "$PLAN_CONF_FILE" | grep "^Section=" | cut -d'=' -f2 | sed 's/"//g')
PLAN_GROUP=$(sed -n "/\[Plan-${1}\]/,/\[/p" "$PLAN_CONF_FILE" | grep "^Group=" | cut -d'=' -f2 | sed 's/"//g')
PLAN_GPG_CHECK=$(sed -n "/\[Plan-${1}\]/,/\[/p" "$PLAN_CONF_FILE" | grep "^GpgCheck=" | cut -d'=' -f2 | sed 's/"//g')
#PLAN_GPG_CHECK="yes" # par défaut à yes pour les tests
PLAN_GPG_RESIGN=$(sed -n "/\[Plan-${1}\]/,/\[/p" "$PLAN_CONF_FILE" | grep "^GpgResign=" | cut -d'=' -f2 | sed 's/"//g')
#PLAN_GPG_RESIGN="yes" # par défaut à yes pour les tests

# Initialisation de variables supplémentaires
PLAN_GROUP_LIST=""
PLAN_REPO_REALNAME=""
PLAN_REPO_HOSTNAME=""

if [ -z "$PLAN_ACTION" ];then
	PLAN_ERROR_MSG="${PLAN_ERROR_MSG}\nPlanif erreur 1 : Aucune action spécifiée"
	clean_exit
fi

if [ -z "$PLAN_REPO_NAME" ] && [ -z "$PLAN_GROUP" ];then
	PLAN_ERROR_MSG="${PLAN_ERROR_MSG}\nPlanif erreur 2 : Aucun repo ou groupe spécifié"
	clean_exit
fi

# Si l'action est 'update' alors on doit avoir renseigné PLAN_GPG_CHECK (+ PLAN_GPG_RESIGN pour redhat)
if [ "$PLAN_ACTION" == "update" ];then
	if [ -z "$PLAN_GPG_CHECK" ];then
		PLAN_ERROR_MSG="${PLAN_ERROR_MSG}\nPlanif erreur 5 : Vérification des signatures GPG non spécifié"
		clean_exit
	fi

	if [ "$OS_TYPE" == "Redhat" ];then
		if [ -z "$PLAN_GPG_RESIGN" ];then
			PLAN_ERROR_MSG="${PLAN_ERROR_MSG}\nPlanif erreur 6: Signature des paquets avec GPG non spécifié"
			clean_exit
		fi
	fi
fi


# On va traiter soit un repo soit un groupe de repo, ça ne peut pas être les deux, donc on vérifie que PLAN_REPO et PLAN_GROUP ne sont pas tous les deux renseignés en même temps :
if ([ ! -z "$PLAN_REPO_NAME" ] && [ ! -z "$PLAN_GROUP" ]);then
	if [ "$OS_TYPE" == "Redhat" ];then PLAN_ERROR_MSG="${PLAN_ERROR_MSG}\nPlanif erreur 7 : Il n'est pas possible de traiter à la fois un repo et un groupe de repos";fi
	if [ "$OS_TYPE" == "Debian" ];then PLAN_ERROR_MSG="${PLAN_ERROR_MSG}\nPlanif erreur 7 : Il n'est pas possible de traiter à la fois une section et un groupe de sections";fi
	clean_exit
fi

# Si on a renseigné un seul repo à traiter alors il faut vérifier qu'il existe dans la liste (il a pu être supprimé depuis que la planification a été créée)
# Puis il faut récupérer son vrai nom (Redhat) ou son hôte source (Debian)
if [ ! -z "$PLAN_REPO_NAME" ];then
	if [ "$OS_TYPE" == "Redhat" ];then
		# Vérification que le repo existe
		if ! grep -q "^Name=\"${PLAN_REPO_NAME}\"" $LISTE_REPO;then
			PLAN_ERROR_MSG="${PLAN_ERROR_MSG}\nPlanif erreur 14 : Le repo ${PLAN_REPO_NAME} n'existe pas"
			clean_exit
		fi

		# Récupération du repo source
		PLAN_REPO_REALNAME=$(grep "^Name=\"${PLAN_REPO_NAME}\"" $LISTE_REPO | awk -F ',' '{print $2}' | cut -d'=' -f2 | sed 's/"//g')
		if [ -z "$PLAN_REPO_REALNAME" ];then
			PLAN_ERROR_MSG="${PLAN_ERROR_MSG}\nPlanif erreur 8 : Impossible de récupérer le nom du repo source"
			clean_exit
		fi
	fi

	if [ "$OS_TYPE" == "Debian" ];then
		# On vérifie qu'on a bien renseigné la distribution et la section
		if [ -z "$PLAN_REPO_DIST" ];then
			PLAN_ERROR_MSG="${PLAN_ERROR_MSG}\nPlanif erreur 3 : Aucune distribution spécifiée"
			clean_exit
		fi
		if [ -z "$PLAN_REPO_SECTION" ];then
			PLAN_ERROR_MSG="${PLAN_ERROR_MSG}\nPlanif erreur 4 : Aucune section spécifiée"
			clean_exit
		fi

		# Vérification que la section existe
		if ! grep -q "^Name=\"${PLAN_REPO_NAME}\",Host=\".*\",Dist=\"${PLAN_REPO_DIST}\",Section=\"${PLAN_REPO_SECTION}\"" $LISTE_REPO;then
			PLAN_ERROR_MSG="${PLAN_ERROR_MSG}\nPlanif erreur 14 : La section ${PLAN_REPO_SECTION} du repo ${PLAN_REPO_NAME} (distribution ${PLAN_REPO_DIST}) n'existe pas"
			clean_exit
		fi

		# Récupération de l'hote source
		PLAN_REPO_HOSTNAME=$(grep "^Name=\"${PLAN_REPO_NAME}\"" $LISTE_REPO | awk -F ',' '{print $2}' | cut -d'=' -f2 | sed 's/"//g')
		if [ -z "$PLAN_REPO_HOSTNAME" ];then
			PLAN_ERROR_MSG="${PLAN_ERROR_MSG}\nPlanif erreur 8 : Impossible de récupérer le nom de l'hôte source"
			clean_exit
		fi
	fi
fi


# Si on a renseigné un groupe (commence par @) plutôt qu'un seul repo à traiter, alors on vérifie que le groupe existe dans le fichier de groupe (il a pu être supprimé depuis que la planification a été créée)
# Puis on récupère toute la liste du groupe
if [ ! -z "$PLAN_GROUP" ];then
	# Vérification que le groupe existe
	if ! grep -q "\[${PLAN_GROUP}\]" $REPO_GROUPS_FILE;then
		PLAN_ERROR_MSG="${PLAN_ERROR_MSG}\nPlanif erreur 14 : Le groupe ${PLAN_GROUP} n'existe pas"
		clean_exit
	fi

	# on récupère tous les repos du groupe
	PLAN_GROUP_LIST=$(cat "$REPO_GROUPS_FILE" | sed -n "/${PLAN_GROUP}/,/^@/p" | egrep "^Name=\".*\"")

	if [ -z "$PLAN_GROUP_LIST" ];then
		if [ "$OS_TYPE" == "Redhat" ];then PLAN_ERROR_MSG="${PLAN_ERROR_MSG}\nPlanif erreur 9 : Il n'y a aucun repo renseigné dans le groupe ${PLAN_GROUP}.";fi
		if [ "$OS_TYPE" == "Debian" ];then PLAN_ERROR_MSG="${PLAN_ERROR_MSG}\nPlanif erreur 9 : Il n'y a aucune section renseignée dans le groupe ${PLAN_GROUP}.";fi
		clean_exit
	fi 
fi


## TRAITEMENT ##

# Cas où on traite 1 repo seulement :
if [ ! -z "$PLAN_REPO_NAME" ];then
	# Si $PLAN_ACTION = update alors on met à jour le repo
	if [ "$PLAN_ACTION" == "update" ];then
		if [ "$OS_TYPE" == "Redhat" ];then echo "Mise à jour du repo ${PLAN_REPO_NAME}";fi
		if [ "$OS_TYPE" == "Debian" ];then echo "Mise à jour de la section ${PLAN_REPO_SECTION} du repo ${PLAN_REPO_NAME} (distribution ${PLAN_REPO_DIST})";fi
		if [ "$OS_TYPE" == "Redhat" ];then
			updateRepo --gpg-check ${PLAN_GPG_CHECK} --gpg-resign ${PLAN_GPG_RESIGN} --repo-name ${PLAN_REPO_NAME} --repo-real-name ${PLAN_REPO_REALNAME}
		fi
		if [ "$OS_TYPE" == "Debian" ];then
			updateRepo --gpg-check ${PLAN_GPG_CHECK} --repo-name ${PLAN_REPO_NAME} --repo-host-name ${PLAN_REPO_HOSTNAME} --repo-dist ${PLAN_REPO_DIST} --repo-section ${PLAN_REPO_SECTION}
		fi
	fi


	# Si $PLAN_ACTION contient -> alors il s'agit d'un changement d'env
	if [[ "$PLAN_ACTION" =~ "->" ]];then
		PLAN_REPO_ENV=$(echo $PLAN_ACTION | awk -F '->' '{print $1}')
		PLAN_REPO_NEXTENV=$(echo $PLAN_ACTION | awk -F '->' '{print $2}')
		if [ -z "$PLAN_REPO_ENV" ] || [ -z "$PLAN_REPO_NEXTENV" ];then
			PLAN_ERROR_MSG="${PLAN_ERROR_MSG}\nPlan erreur 10 : envs non définis"
			clean_exit
		fi
		
		if [ "$OS_TYPE" == "Redhat" ];then echo "Changement d'env (${PLAN_REPO_ENV} -> ${PLAN_REPO_NEXTENV}) du repo ${PLAN_REPO_NAME}";fi
		if [ "$OS_TYPE" == "Debian" ];then echo "Changement d'env (${PLAN_REPO_ENV} -> ${PLAN_REPO_NEXTENV}) de la section ${PLAN_REPO_SECTION} du repo ${PLAN_REPO_NAME} (distribution ${PLAN_REPO_DIST})";fi
		if [ "$OS_TYPE" == "Redhat" ];then
			changeEnv --repo-name ${PLAN_REPO_NAME} --repo-env ${PLAN_REPO_ENV} --repo-new-env ${PLAN_REPO_NEXTENV}
		fi
		if [ "$OS_TYPE" == "Debian" ];then
			changeEnv --repo-name ${PLAN_REPO_NAME} --repo-dist ${PLAN_REPO_DIST} --repo-section ${PLAN_REPO_SECTION} --repo-env ${PLAN_REPO_ENV} --repo-new-env ${PLAN_REPO_NEXTENV}
		fi
	fi
fi


# Cas où on traite un groupe de repo :
if ([ ! -z "$PLAN_GROUP" ] && [ ! -z "$PLAN_GROUP_LIST" ]);then
	for LINE in $(echo "$PLAN_GROUP_LIST");do
		# Pour chaque ligne on récupère les infos du repo/section
		if [ "$OS_TYPE" == "Redhat" ];then 
			GROUP_REPO_NAME=$(echo $LINE | awk -F ',' '{print $1}' | cut -d'=' -f2 | sed 's/"//g')
			GROUP_REPO_REALNAME=$(grep "^Name=\"${GROUP_REPO_NAME}\"" $LISTE_REPO | awk -F ',' '{print $2}' | cut -d'=' -f2 | sed 's/"//g')
		fi
		if [ "$OS_TYPE" == "Debian" ];then
			GROUP_REPO_NAME=$(echo $LINE | awk -F ',' '{print $1}' | cut -d'=' -f2 | sed 's/"//g')
			GROUP_REPO_HOSTNAME=$(grep "^Name=\"${GROUP_REPO_NAME}\"" $LISTE_REPO | awk -F ',' '{print $2}' | cut -d'=' -f2 | sed 's/"//g')
			GROUP_REPO_DIST=$(echo $LINE | awk -F ',' '{print $3}' | cut -d'=' -f2 | sed 's/"//g')
			GROUP_REPO_SECTION=$(echo $LINE | awk -F ',' '{print $4}' | cut -d'=' -f2 | sed 's/"//g')
		fi

		# Si $PLAN_ACTION = update alors on met à jour les repos du groupe
		if [ "$PLAN_ACTION" == "update" ];then
			# Exécution 
			if [ "$OS_TYPE" == "Redhat" ];then echo "Mise à jour du repo ${GROUP_REPO_NAME}";fi
			if [ "$OS_TYPE" == "Debian" ];then echo "Mise à jour de la section ${GROUP_REPO_SECTION} du repo ${GROUP_REPO_NAME} (distribution ${GROUP_REPO_DIST})";fi
			if [ "$OS_TYPE" == "Redhat" ];then
				updateRepo --gpg-check ${PLAN_GPG_CHECK} --gpg-resign ${PLAN_GPG_RESIGN} --repo-name ${GROUP_REPO_NAME} --repo-real-name ${GROUP_REPO_REALNAME}
			fi
			if [ "$OS_TYPE" == "Debian" ];then
				updateRepo --gpg-check ${PLAN_GPG_CHECK} --repo-name ${GROUP_REPO_NAME} --repo-host-name ${GROUP_REPO_HOSTNAME} --repo-dist ${GROUP_REPO_DIST} --repo-section ${GROUP_REPO_SECTION}
			fi
		fi

		# Si $PLAN_ACTION contient -> alors il s'agit d'un changement d'env
		if [[ "$PLAN_ACTION" =~ "->" ]];then
			PLAN_REPO_ENV=$(echo $PLAN_ACTION | awk -F '->' '{print $1}')
			PLAN_REPO_NEXTENV=$(echo $PLAN_ACTION | awk -F '->' '{print $2}')
			if [ -z "$PLAN_REPO_ENV" ] || [ -z "$PLAN_REPO_NEXTENV" ];then
				PLAN_ERROR_MSG="${PLAN_ERROR_MSG}\nPlan erreur 11 : environnements non définis"
				continue
			fi

			if [ "$OS_TYPE" == "Redhat" ];then echo -e "\n\nChangement d'env (${PLAN_REPO_ENV} -> ${PLAN_REPO_NEXTENV}) du repo ${GROUP_REPO_NAME}";fi
			if [ "$OS_TYPE" == "Debian" ];then echo -e "\n\nChangement d'env (${PLAN_REPO_ENV} -> ${PLAN_REPO_NEXTENV}) de la section ${GROUP_REPO_SECTION} du repo ${GROUP_REPO_NAME} (distribution ${GROUP_REPO_DIST})";fi
			if [ "$OS_TYPE" == "Redhat" ];then
				changeEnv --repo-name ${GROUP_REPO_NAME} --repo-env ${PLAN_REPO_ENV} --repo-new-env ${PLAN_REPO_NEXTENV}
			fi
			if [ "$OS_TYPE" == "Debian" ];then
				changeEnv --repo-name ${GROUP_REPO_NAME} --repo-dist ${GROUP_REPO_DIST} --repo-section ${GROUP_REPO_SECTION} --repo-env ${PLAN_REPO_ENV} --repo-new-env ${PLAN_REPO_NEXTENV}
			fi
		fi
	done
fi
