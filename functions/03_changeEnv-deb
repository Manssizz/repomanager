#!/bin/bash

# La fonction a besoin de 6 paramètres pour fonctionner :
# Le nom du repo
# Le nom de la distribution
# Le nom de la section
# L'env de la section
# Le nouvel env de la section
# Si aucun paramètre n'a été passé, alors on les demande (on affiche la liste des repos d'abord, pour aider):

while [ $# -ge 1 ];do case "$1" in
	--repo-name)
		REPO_NAME="$2"
		shift
	;;
	--repo-dist)
		REPO_DIST="$2"
		shift
	;;
	--repo-section)
		REPO_SECTION="$2"
		shift
	;;
	--repo-env)
		REPO_ENV="$2"
		shift
	;;
	--repo-new-env)
		REPO_NEW_ENV="$2"
		shift
	;;
	--repo-description)
		# on shift un coup pour récupérer tous les derniers arguments $* (la description pouvant contenir des espaces, chaque espace est un nouvel argument, c'est pour ça qu'on récupère tout)
		shift
		REPO_DESCRIPTION="$*"
	;;
	*)
	esac
	shift
done

ERROR="0"

if [ "$REPO_DESCRIPTION" == "nodescription" ];then REPO_DESCRIPTION="";fi # Si la description est égale à 'nodescription' alors elle doit être laissée vide

# Si le repo n'était pas présent dans repos.list
if ! egrep -q "^Name=\"${REPO_NAME}\",Host=\".*\",Dist=\"${REPO_DIST}\",Section=\"${REPO_SECTION}\",Env=\"${REPO_ENV}\"" ${REPOS_LIST};then
	(( ERROR++ ))
	echo -e "[${ROUGE} ERREUR ${RESET}] Il n'existe aucune section ${CYAN}${REPO_SECTION}${RESET} du repo ${CYAN}${REPO_NAME}${RESET} (distribution : ${REPO_DIST}) en ${REPO_ENV} sur ce serveur..."
	MSG_MAIN_ERROR="${MSG_MAIN_ERROR}\n Erreur : Il n'existe aucune section ${CYAN}${REPO_SECTION}${RESET} du repo ${CYAN}${REPO_NAME}${RESET} (distribution : ${REPO_DIST}) en ${REPO_ENV} sur ce serveur..."
	if [ "$PLAN_EXEC" -eq "1" ];then # Si cette tâche est exécutée par une planification, alors il faut incrémenter la variable d'erreur utilisée par la fonction planification
		(( PLAN_ERROR++ ))
	fi
fi

# On traite uniquement si il n'y a pas eu d'erreur précédemment
if [ "$ERROR" -eq "0" ];then
	# Récupère la date vers laquelle on va faire pointer le nouvel env
	REPO_DATE=$(egrep "^Name=\"${REPO_NAME}\",Host=\".*\",Dist=\"${REPO_DIST}\",Section=\"${REPO_SECTION}\",Env=\"${REPO_ENV}\"" "${REPOS_LIST}" | awk -F ',' '{print $6}' | cut -d'=' -f2 | sed 's/"//g') # On extrait la date de synchro du repo 'base' de test qui sera passé en prod
	# Récupère le nom de l'hote
	REPO_HOST=$(egrep "^Name=\"${REPO_NAME}\",Host=\".*\",Dist=\"${REPO_DIST}\",Section=\"${REPO_SECTION}\",Env=\"${REPO_ENV}\"" "${REPOS_LIST}" | awk -F ',' '{print $2}' | cut -d'=' -f2 | sed 's/"//g') # On extrait la date de synchro du repo 'base' de test qui sera passé en prod
	# Si on n'a pas transmis de description, on va conserver celle actuelle si existe.
	# Si il n'y a pas de description ou qu'aucun repo n'existe actuellement dans l'env $REPO_NEW_ENV, alors le grep ne renverra rien et la description restera vide
	if [ -z "$REPO_DESCRIPTION" ];then
		REPO_DESCRIPTION=$(egrep "^Name=\"${REPO_NAME}\",Host=\".*\",Dist=\"${REPO_DIST}\",Section=\"${REPO_SECTION}\",Env=\"${REPO_NEW_ENV}\"" "${REPOS_LIST}" | awk -F ',' '{print $7}' | cut -d'=' -f2 | sed 's/"//g') # On extrait la description actuelle afin de la reporter sur la nouvelle version
	fi

	# Dernière vérif : on vérifie que le repo n'a pas déjà été passé en prod (par exemple par quelqu'un d'autre), dans ce cas on annule l'opération
	if egrep -q "^Name=\"${REPO_NAME}\",Host=\".*\",Dist=\"${REPO_DIST}\",Section=\"${REPO_SECTION}\",Env=\"${REPO_NEW_ENV}\",Date=\"${REPO_DATE}\"" "${REPOS_LIST}";then
		(( ERROR++ ))
		echo -e "[$ROUGE ERREUR $RESET] Ce repo est déjà en ${REPO_NEW_ENV} au ${REPO_DATE}\n"
		MSG_MAIN_ERROR="${MSG_MAIN_ERROR}\n Ce repo est déjà en ${REPO_NEW_ENV} au ${REPO_DATE}\n"
		if [ "$PLAN_EXEC" -eq "1" ];then # Si cette tâche est exécutée par une planification, alors il faut incrémenter la variable d'erreur utilisée par la fonction planification
			(( PLAN_ERROR++ ))
		fi
	fi
fi

# On continue uniquement si il n'y a pas eu d'erreur précédemment
if [ "$ERROR" -eq "0" ];then

	echo -e "\nDébut de l'opération"
	sleep 1
	cd ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/

	####

	# Deux cas possibles : 
	# - ce repo n'avait pas de version en prod, on crée simplement un lien symbo
	# - ce repo avait déjà une version en prod, on modifie le lien symbo et on passe la version précédente en archive
	# Cas 1 :
	if ! egrep -q "^Name=\"${REPO_NAME}\",Host=\".*\",Dist=\"${REPO_DIST}\",Section=\"${REPO_SECTION}\",Env=\"${REPO_NEW_ENV}\"" "${REPOS_LIST}";then	# Cas 1 : pas de version déjà en ${REPO_NEW_ENV}
		echo -ne "Création du lien symbolique :\t\t\t"
		ln -s ${REPO_DATE}_${REPO_SECTION}/ ${REPO_SECTION}_${REPO_NEW_ENV}
		if [ $? -eq "0" ];then
			echo -e "[${VERT} OK ${RESET}]"
		else
			(( ERROR++ ))
			echo -e "[${ROUGE} ERREUR ${RESET}] Problème lors de la création du lien symbolique"
			MSG_MAIN_ERROR="${MSG_MAIN_ERROR}\n Problème lors de la création du lien symbolique"
			if [ "$PLAN_EXEC" -eq "1" ];then # Si cette tâche est exécutée par une planification, alors il faut incrémenter la variable d'erreur utilisée par la fonction planification
				(( PLAN_ERROR++ ))
			fi
		fi

		# On continue uniquement si il n'y a pas eu d'erreur précédemment
		if [ "$ERROR" -eq "0" ];then
			echo -ne "Mise à jour des informations dans repos.list :\t\t"
			echo "Name=\"${REPO_NAME}\",Host=\"${REPO_HOST}\",Dist=\"${REPO_DIST}\",Section=\"${REPO_SECTION}\",Env=\"${REPO_NEW_ENV}\",Date=\"${REPO_DATE}\",Description=\"${REPO_DESCRIPTION}\"" >> ${REPOS_LIST} &&
			echo -e "[${VERT} OK ${RESET}]"
		fi

	# Cas 2 : Il y a déjà une version en prod qui va donc passer en archive. Modif du lien symbo + passage de la version précédente en archive :
	else
		echo -ne "Modification du lien symbolique :\t"
		unlink "${REPO_SECTION}_${REPO_NEW_ENV}" && # Suppression du lien symbolique
		ln -s "${REPO_DATE}_${REPO_SECTION}/" "${REPO_SECTION}_${REPO_NEW_ENV}" # Puis on le recrée en le faisant pointer sur la nouvelle version en prod
		if [ $? -eq "0" ];then
			echo -e "[${VERT} OK ${RESET}]"
		else
			(( ERROR++ ))
			echo -e "[${ROUGE} ERREUR ${RESET}] Problème lors de la création du lien symbolique"
			MSG_MAIN_ERROR="${MSG_MAIN_ERROR}\n Problème lors de la création du lien symbolique"
			if [ "$PLAN_EXEC" -eq "1" ];then # Si cette tâche est exécutée par une planification, alors il faut incrémenter la variable d'erreur utilisée par la fonction planification
				(( PLAN_ERROR++ ))
			fi
		fi

		# On continue uniquement si il n'y a pas eu d'erreur précédemment
		if [ "$ERROR" -eq "0" ];then
			OLD_REPO_DATE=$(egrep "^Name=\"${REPO_NAME}\",Host=\".*\",Dist=\"${REPO_DIST}\",Section=\"${REPO_SECTION}\",Env=\"${REPO_NEW_ENV}\"" "${REPOS_LIST}" | awk -F ',' '{print $6}' | cut -d'=' -f2 | sed 's/"//g') && # On récupère l'ancienne date de prod afin de la passer en tant que date n-1
			OLD_REPO_DESCRIPTION=$(egrep "^Name=\"${REPO_NAME}\",Host=\".*\",Dist=\"${REPO_DIST}\",Section=\"${REPO_SECTION}\",Env=\"${REPO_NEW_ENV}\"" "${REPOS_LIST}" | awk -F ',' '{print $7}' | cut -d'=' -f2 | sed 's/"//g') && # On récupère l'ancienne description de prod pour la conserver
			echo -ne "Passage de l'ancienne version de ${REPO_NEW_ENV} en archive :\t"
			mv "${OLD_REPO_DATE}_${REPO_SECTION}/" "99_old_version_${OLD_REPO_DATE}_${REPO_SECTION}/" # On renomme l'ancienne version en tant que 99_old_version_JJ-MM-AAAA_base/
			if [ $? -eq "0" ];then
				echo -e "[${VERT} OK ${RESET}]"
			else
				(( ERROR++ ))
				echo -e "[${ROUGE} ERREUR ${RESET}] Problème lors du renommage du répertoire ${OLD_REPO_DATE}_${REPO_SECTION} vers 99_old_version_${OLD_REPO_DATE}_${REPO_SECTION}"
				MSG_MAIN_ERROR="${MSG_MAIN_ERROR}\n Problème lors du renommage du répertoire ${OLD_REPO_DATE}_${REPO_SECTION} vers 99_old_version_${OLD_REPO_DATE}_${REPO_SECTION}"
				if [ "$PLAN_EXEC" -eq "1" ];then # Si cette tâche est exécutée par une planification, alors il faut incrémenter la variable d'erreur utilisée par la fonction planification
					(( PLAN_ERROR++ ))
				fi
			fi
		fi	
			
		# On continue uniquement si il n'y a pas eu d'erreur précédemment
		if [ "$ERROR" -eq "0" ];then
			echo -ne "Mise à jour des informations dans repos.list :\t"
			sed -i /^Name=\"${REPO_NAME}\",Host=\"${REPO_HOST}\",Dist=\"${REPO_DIST//\//\\/}\",Section=\"${REPO_SECTION}\",Env=\"${REPO_NEW_ENV}\",Date=\"${OLD_REPO_DATE}\"/d ${REPOS_LIST} &&	 # On supprime la ligne de l'ancien repo en prod dans le fichier repos.list (par exemple)
			echo "Name=\"${REPO_NAME}\",Host=\"${REPO_HOST}\",Dist=\"${REPO_DIST}\",Section=\"${REPO_SECTION}\",Env=\"${REPO_NEW_ENV}\",Date=\"${REPO_DATE}\",Description=\"${REPO_DESCRIPTION}\"" >> ${REPOS_LIST} # Puis on la remplace en ajoutant le nouveau repo base:prod:date:description dans le fichier repos.list
			if [ $? -eq "0" ];then
				echo -e "[${VERT} OK ${RESET}]"
			else
				(( ERROR++ ))
				echo -e "[${ROUGE} ERREUR ${RESET}] pendant l'ajout des informations"
				MSG_MAIN_ERROR="${MSG_MAIN_ERROR}\n Erreur pendant l'ajout des informations"
				if [ "$PLAN_EXEC" -eq "1" ];then # Si cette tâche est exécutée par une planification, alors il faut incrémenter la variable d'erreur utilisée par la fonction planification
					(( PLAN_ERROR++ ))
				fi
			fi
		fi

		# On continue uniquement si il n'y a pas eu d'erreur précédemment
		if [ "$ERROR" -eq "0" ];then
			echo -ne "Mise à jour des informations dans repos-archive.list :\t" &&
			echo "Name=\"${REPO_NAME}\",Host=\"${REPO_HOST}\",Dist=\"${REPO_DIST}\",Section=\"${REPO_SECTION}\",Date=\"${OLD_REPO_DATE}\",Description=\"${OLD_REPO_DESCRIPTION}\"" >> $REPOS_ARCHIVE_LIST
			if [ $? -eq "0" ];then
				echo -e "[${VERT} OK ${RESET}]"
			else
				(( ERROR++ ))
				echo -e "[${ROUGE} ERREUR ${RESET}] pendant l'ajout des informations"
				MSG_MAIN_ERROR="${MSG_MAIN_ERROR}\n  Erreur pendant l'ajout des informations"
				if [ "$PLAN_EXEC" -eq "1" ];then # Si cette tâche est exécutée par une planification, alors il faut incrémenter la variable d'erreur utilisée par la fonction planification
					(( PLAN_ERROR++ ))
				fi
			fi
		fi

		# On continue uniquement si il n'y a pas eu d'erreur précédemment
		if [ "$ERROR" -eq "0" ];then
			echo -ne "Application des droits sur la section archivée :\t"
			find ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/99_old_version_${OLD_REPO_DATE}_${REPO_SECTION}/ -type f -exec chmod 0660 {} \;
			find ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/99_old_version_${OLD_REPO_DATE}_${REPO_SECTION}/ -type d -exec chmod 0770 {} \;
			echo -e "[${VERT} OK ${RESET}]"
		fi
	fi

	# On continue uniquement si il n'y a pas eu d'erreur précédemment
	if [ "$ERROR" -eq "0" ];then
		echo -ne "Application des droits sur la section modifiée :\t"
		find ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${REPO_DATE}_${REPO_SECTION}/ -type f -exec chmod 0660 {} \;
		find ${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${REPO_DATE}_${REPO_SECTION}/ -type d -exec chmod 0770 {} \;
		echo -e "[${VERT} OK ${RESET}]"

		echo -e "${VERT}Opération terminée${RESET}"
	fi
fi